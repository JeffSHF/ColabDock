import os
import argparse
import random
from ast import literal_eval
from functools import partial
import joblib
import numpy as np
from Bio.PDB.PDBParser import PDBParser
import pandas as pd

from colabdesign.af.prep import prep_pdb
from colabdesign.af.alphafold.model import model

def gen_1vN_from_1v1(x, y, dm, N_1vN, rest_thres):
    iy_new = [y]
    y_pos = np.where((dm[x, :]>1) & (dm[x, :]<rest_thres))[0]
    y_pos = list(y_pos)
    y_pos.remove(y)
    pos_num = random.choice(range(N_1vN))
    pos_num = min(pos_num, len(y_pos))
    if pos_num > 0:
        y_pos_sel = random.sample(y_pos, pos_num)
        iy_new.extend(y_pos_sel)
    if len(iy_new) < N_1vN:
        y_neg = np.where(dm[x, :]>rest_thres)[0]
        neg_num = N_1vN - len(iy_new)
        y_neg_sel = random.sample(list(y_neg), neg_num)
        iy_new.extend(y_neg_sel)
    return iy_new

def gen_neg_1vN(dm, N_1vN, rest_thres):
    x, _ = np.where(dm > rest_thres)
    ix = random.choice(x)
    iys = np.where(dm[ix, :] > rest_thres)[0]
    iys = random.sample(list(iys), N_1vN)
    return [ix, iys]

def template_pdbid_map(molecule,chains):
    '''Store AF2 order, residue segment id,residue name of given chains.

    Params
    ======
    - moleculue: a PDB bio-molecule (complex) parsed by BioPython.
    - chains: Sequence[str],a sequence of docking chains,need to be the same with config.py.

    Returns
    =======
    DataFrame[chain name, AF2 order, residue segment id, residue type]]
    '''
    mapper = {'chain':[],'af2id':[],'tmpid':[],'resname':[]}
    res_total = 1 # af2 order starts from 1
    for cid in chains:
        chain = molecule[cid]
        res_info = [(res.get_id(),res.resname) for res in chain]
        # [((hetatm flag,seg id,insert code),resname),...]
        res_info = [(res_t[0][1],res_t[1]) for res_t in res_info if res_t[0][0]==' '] 
        # [(seg id,resname),...] ,HETATM residues ignored
        mapper['tmpid'].extend(info[0] for info in res_info)
        mapper['resname'].extend(info[1] for info in res_info)
        len_chain = len(res_info)
        mapper['chain'].extend(cid for _ in range(len_chain))
        mapper['af2id'].extend(range(res_total,res_total+len_chain))
        res_total += len_chain
    return pd.DataFrame(mapper)

def tmp2afid(pdbid_map,chains,res_pair):
    """Convert a template residue segment id pair into AF2 orders.
    
    Params
    ======
    - pdbid_map: id mapper generated by `template_pdbid_map`
    - chains: a group of 2 chains' names
    - res_pair: initial residue id pair
    
    Returns
    =======
    A tuple of 2 AF2 orders of given residues.
    """
    masks = [(pdbid_map['chain']==chain_i) & (pdbid_map['tmpid']==res_i) for (chain_i,res_i) in zip(chains,res_pair)]
    return [pdbid_map[mask]['af2id'].iloc[0] for mask in masks]

def af2tmpid(pdbid_map,chains,ovN_pair):
    """Convert an 1vN(1v1) AF2 order pair into template residues' segment ids pair.
    
    Params
    ======
    - pdbid_map: id mapper generated by `template_pdbid_map`
    - chains: a group of 2 chains' names
    - res_pair: 2 af2 orders of given residues.
    
    Returns
    =======
    A tuple of 2 initial residue ids.
    """
    chain1,chain2=chains
    res1,res2s=ovN_pair
    res1=tuple(pdbid_map[(pdbid_map['chain']== chain1)&(pdbid_map['af2id']==res1)][['tmpid','resname']].iloc[0])
    if hasattr(res2s,'__len__'): # 1vN
        masks=((pdbid_map['chain']== chain2)&(pdbid_map['af2id']==res2) for res2 in res2s)
        res2s=[tuple(pdbid_map[mask][['tmpid','resname']].iloc[0]) for mask in masks]
    else: # 1v1
        masks=(pdbid_map['chain']== chain2)&(pdbid_map['af2id']==res2s)
        res2s=tuple(pdbid_map[masks][['tmpid','resname']].iloc[0])
    return [res1,res2s]

if __name__ == '__main__':
    description = '''randomly extract restraints from a given complex structure.\n
    An example: `python extract_rest.py ./protein/4INS4/PDB/native.pdb A,B,C,D A,D 1v1 -i 45,12`'''
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('pdb', type=str, help='input complex structure')
    parser.add_argument('chains', type=str, help='docking chains, this parameter should be the same as that in the config.py file')
    parser.add_argument('chains_rest', type=str, help='sample restraints between which two chains')
    parser.add_argument('rest_type', type=str, help='sampled restraints type. Please choose one type from 1v1, 1vN, MvN, and repulsive')
    parser.add_argument('--rest_thres', type=float, default=8.0, help='distance threshold of the restraints. Default 8.0')
    parser.add_argument('--N', type=int, default=5, help='In the sampled 1vN restraint, the distance between a residue and at least one of N residues is below a certain value. Default 5.')
    parser.add_argument('--M', type=int, default=2, help='number of 1vN restraints in the sampled MvN restraint. Default 2.')
    parser.add_argument('--num', type=int, default=1, help='number of sampled restraints. Default 1.')
    parser.add_argument('--save_path', type=str, default=None, help='the file to save the sampled restraints using joblib package. Default None prints the restraints to stdout.')
    parser.add_argument('--init','-i',type=str, default=None, help='initial residue indices in template pdb file.Accept 1v1/repulsive restraint(s) only and ignore other restraint arguments if it is set.')
    parser.add_argument('--verbose','-v',action='store_true' , help='print more information about the restrants.Double check the initial residue names since pdb segment ids can be different from their papers.')

    # parse argument
    args = parser.parse_args()
    file = args.pdb
    chains = args.chains
    chains_rest = args.chains_rest
    rest_type = args.rest_type
    rest_thres = args.rest_thres
    N_1vN = args.N
    M_MvN = args.M
    num = args.num
    save_path = args.save_path
    verbose = args.verbose
    init_ids = args.init

    # check argument
    if not os.path.exists(file):
        raise Exception('The pdb file you provide does not exist!')
    
    if rest_type not in ['1v1', '1vN', 'MvN', 'repulsive']:
        raise Exception('The rest_type argument accepts 1v1, 1vN, MvN, or repulsive.')
    
    if N_1vN <= 1:
        raise Exception('N_1vN should be larger than 1.')
    
    if num < 1:
        raise Exception('At least generate one restraint.')
    
    chains_all_l = [c.strip() for c in chains.split(',')]
    chains_rest_l = [c.strip() for c in chains_rest.split(',')]

    pdb_parser = PDBParser(QUIET=True)
    structures = pdb_parser.get_structure('none', file)
    structure = list(structures.get_models())[0]
    for ichain in chains_all_l:
        if ichain not in structure:
            raise Exception(f'Chain {ichain} is not in the provided pdb file!')
    
    for ichain in chains_rest_l:
        if ichain not in chains_all_l:
            raise Exception(f'Chain {ichain} in chains_rest is not in chains!')
    
    if len(set(chains_rest_l)) != 2 or len(chains_rest_l) != 2:
        raise Exception('Currently, this script only generates restraints between two chains.')
    mapper = template_pdbid_map(structure,chains_all_l)

    # cal distance matrix
    pdb = prep_pdb(file, chain=chains, for_alphafold=False)
    x_beta, _ = model.modules.pseudo_beta_fn(aatype=pdb['batch']['aatype'],
                                             all_atom_positions=pdb['batch']["all_atom_positions"],
                                             all_atom_mask=pdb['batch']["all_atom_mask"])
    dm = np.sqrt(np.square(x_beta[:,None] - x_beta[None,:]).sum(-1))

    # sample restraints
    lens = [(pdb["idx"]["chain"] == c).sum() for c in chains_all_l]
    boundaries = [0] + list(np.cumsum(lens))
    ind = chains_all_l.index(chains_rest_l[0])
    a_start, a_stop = boundaries[ind], boundaries[ind+1]
    ind = chains_all_l.index(chains_rest_l[1])
    b_start, b_stop = boundaries[ind], boundaries[ind+1]
    mask = np.zeros_like(dm)
    mask[a_start:a_stop, b_start:b_stop] = 1
    dm *= mask
    
    if init_ids is not None:
        if rest_type in ['1vN','MvN']:
            raise ValueError('Accept 1v1/repulsive restraint(s) only when init_ids are given.')
        init_ids=np.array(literal_eval(init_ids))# works for `45,12`,`[,]`, `[],[]` and `[[],[]]`
        if len(init_ids.shape)==1:
            init_ids=init_ids[np.newaxis,:] # convert to 2D
        rest = [tmp2afid(mapper,chains_rest_l,pair) for pair in init_ids]
        # 1v1 and repulsive
        if len(rest)==0:
            raise IndexError('Given 1v1 residue segment ids not found.')

    elif rest_type == '1v1':
        x, y = np.where((dm>1) & (dm<rest_thres))
        if len(x) == 0:
            raise Exception('No restraint between the provided two chains!')
        if num > len(x):
            print(f'Cannot sample {num} restraints. There are only {len(x)} restraints between the provided two chains. '
                  f'Consider to generate {len(x)} restraints!')
            num = len(x)

        idx = random.sample(range(len(x)), num)
        x = [x[ind] for ind in idx]
        y = [y[ind] for ind in idx]
        rest = [[x[i]+1, y[i]+1] for i in range(len(x))]
    elif rest_type == 'repulsive':
        x, y = np.where(dm > rest_thres)
        if len(x) == 0:
            raise Exception('No restraint between the provided two chains!')
        if num > len(x):
            print(f'Cannot sample {num} restraints. There are only {len(x)} restraints between the provided two chains. '
                  f'Consider to generate {len(x)} restraints!')
            num = len(x)

        idx = random.sample(range(len(x)), num)
        x = [x[ind] for ind in idx]
        y = [y[ind] for ind in idx]
        rest = [[x[i]+1, y[i]+1] for i in range(len(x))]
    elif rest_type == '1vN':
        x, y = np.where((dm>1) & (dm<rest_thres))
        if len(x) == 0:
            raise Exception('No restraint between the provided two chains!')
        if num > len(x):
            print(f'Cannot sample {num} restraints. There are only {len(x)} restraints between the provided two chains. '
                  f'Consider to generate {len(x)} restraints!')
            num = len(x)

        idx = random.sample(range(len(x)), num)
        x = [x[ind] for ind in idx]
        y = [y[ind] for ind in idx]
        y_new = [gen_1vN_from_1v1(x[i], y[i], dm, N_1vN, rest_thres) for i in range(len(x))]
        rest = [[x[i]+1, list(np.array(y_new[i])+1)] for i in range(len(x))]
    elif rest_type == 'MvN':
        x, y = np.where((dm>1) & (dm<rest_thres))
        if len(x) == 0:
            raise Exception('No restraint between the provided two chains!')
        if num > len(x):
            print(f'Cannot sample {num} restraints. There are only {len(x)} restraints between the provided two chains. '
                  f'Consider to generate {len(x)} restraints!')
            num = len(x)

        rest_1v1 = [[x[i], y[i]] for i in range(len(x))]
        random.shuffle(rest_1v1)
        rest_1v1 = np.array(rest_1v1, dtype=np.int32)
        x, y = list(rest_1v1[:, 0]), list(rest_1v1[:, 1])

        num_1vN = len(x) // num
        posnum_1v1 = [random.choice(range(1, min(num_1vN, M_MvN)+1)) for _ in range(num)]
        rest = []
        for i in range(num):
            iMvN = []
            for j in range(posnum_1v1[i]):
                ix, iy = x[num_1vN*i+j], y[num_1vN*i+j]
                iMvN.append([ix+1, list(np.array(gen_1vN_from_1v1(ix, iy, dm, N_1vN, rest_thres))+1)])
            for j in range(M_MvN-posnum_1v1[i]):
                neg_1vN = gen_neg_1vN(dm, N_1vN, rest_thres)
                iMvN.append([neg_1vN[0]+1, list(np.array(neg_1vN[1])+1)])
            iMvN.append(random.choice(range(1, posnum_1v1[i]+1)))
            rest.append(iMvN)

    if verbose:
        print(f'The sampled {rest_type} restraints:\n{rest}')
        rest_dataframe=pd.DataFrame(rest)
        if rest_dataframe[0].dtype==object: # MvN
            rest_dataframe=rest_dataframe.iloc[:,:-1] # last column is --num
            _ ,cols=rest_dataframe.shape
            for col in range(cols):
                col_df=pd.DataFrame(rest_dataframe[col].tolist(),columns=[0,1])
                rest_dataframe[col]=col_df.apply(partial(af2tmpid,mapper,chains_rest_l),axis=1)
            rest_dataframe=rest_dataframe.T
        else: # n*1vN, n*1v1,repulsive
            rest_dataframe=rest_dataframe.apply(partial(af2tmpid,mapper,chains_rest_l),axis=1)
        with pd.option_context('display.max_rows',None,'display.max_colwidth',None,'display.max_columns',None):
            print(f'\nThe initial restraints:\n{rest_dataframe}')
    if save_path is not None:
        joblib.dump(rest, save_path)
    else:
        print(f'The sampled {rest_type} restraints:\n{rest}')
        
        



    

